package Algorithms;

import java.util.ArrayList;

import Graph_Generator.Vertex;
import Graph_Generator.functionnode;
import Graph_Generator.graphEdge;
import Algorithms.findShortestPathWithConv;
import Graph_Reader.graphEdges;
import Graph_Reader.graphVertices;

import java.awt.image.AreaAveragingScaleFilter;
import java.lang.reflect.Array;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Set;
import java.util.TreeMap;

/*
*   For the following code, we have used the pseudocode simplification algorithms defined by DZ and EG
*
*   Code is generated for Maryamsadat Jalalitabar
*   Algorithm is generated by Danyang Zheng
*   Algorithm is modified by Evrim Guler
*   Implementation is done by Evrim Guler
*
*   Feb 12th, 2018
*/

public class TuneUpWithConv {

    ArrayList<Vertex> substrateNodes;
    ArrayList<ArrayList<Vertex>> givenChain;
    ArrayList<graphEdge> graphEdges;
    ArrayList<functionnode> virtualNodes;
    String fileName;
    int bandWidth;
    int indexValue;
    TreeMap<Integer, ArrayList<Integer>> treemap;
    ArrayList<Integer> usedSub;
    int numOfGroups;
    String substrateNet;

    // generate a constructor with mapped chain, substrate graph, virtual request,
    // and file name
    // public TuneUp(ArrayList<ArrayList<Vertex>> mappedChain, ArrayList<Vertex>
    // substrateGraph, ArrayList<graphEdge> Edges, ArrayList<functionnode> VNFs,
    // String file, int BW) {
    public TuneUpWithConv(ArrayList<ArrayList<Vertex>> mappedChain, ArrayList<Vertex> substrateGraph,
                  ArrayList<graphEdge> Edges, ArrayList<functionnode> VNFs, String file, int BW,
                  TreeMap<Integer, ArrayList<Integer>> treemapFinal, ArrayList<Integer> usedSubSFC, int numOfGroups, String subnet) {
        this.bandWidth = BW;
        this.fileName = file;
        this.givenChain = mappedChain;
        this.graphEdges = Edges;
        this.substrateNodes = substrateGraph;
        this.virtualNodes = VNFs;
        this.treemap = treemapFinal;
        this.usedSub = usedSubSFC;
        this.numOfGroups = numOfGroups;
        this.substrateNet = subnet;
    }

    public ArrayList<Integer> tuneUpAlgorithm() {

  //      System.out.println("usedSubSFC: " + this.usedSub);
        // int currentIndexValue = this.givenChain.size() - 1;
        int currentIndexValue = getCurrentIndexValue(this.givenChain);
   //     System.out.println("Current Index Value:\t" + currentIndexValue);
        this.indexValue = 0;
        ArrayList<Vertex> connectedChain = getConvertedChainFromGroups(this.givenChain);

        // Vertex currentHeadNode = this.givenChain.get(currentIndexValue).get(0);
        Vertex currentHeadNode = connectedChain.get(currentIndexValue);
    //    System.out.println("currentHeadNode : " + currentHeadNode.getNumber());

//        for (int i = 0; i < connectedChain.size(); i++) {
//            System.out.println(" connectedChain: " + connectedChain.get(i).getNumber());
//        }

        while (currentHeadNode != null) {


            connectedChain = triangleTuneUp(substrateNodes, connectedChain, currentHeadNode, indexValue);
            if (connectedChain == null) {

         //       System.out.println("connectedChain ");
                return null;
            }
            currentHeadNode = null;

            if (this.indexValue == 1 && currentIndexValue > 0) {
                currentIndexValue--;
                // currentHeadNode = this.givenChain.get(currentIndexValue).get(0);
                currentHeadNode = connectedChain.get(currentIndexValue);
            }

    //        System.out.println("Current Index Value:\t" + currentIndexValue);
        }

        ArrayList<Integer> tuneUpPath = getTuneUpPath(connectedChain);

     //   System.out.println("Connected chain Before returning path list:\t" + Arrays.toString(connectedChain.toArray()));

        return tuneUpPath;

    }

    private int getCurrentIndexValue(ArrayList<ArrayList<Vertex>> givenChain2) {

        int currentIndex = 0;
        //we want to get to the head of last group
        for (int i = 0; i < givenChain2.size() - 1; i++) {

            currentIndex += givenChain2.get(i).size();

        }

        return currentIndex;
    }

    private ArrayList<Integer> getTuneUpPath(ArrayList<Vertex> connectedChain) {


     //   System.out.println("Connected new chain in getUpTuneUpPath:\t"+Arrays.toString(connectedChain.toArray()));
        ArrayList<Integer> path = new ArrayList<Integer>();
       // for (int i = 0; i < connectedChain.size() - 1; i++) {
        for (int i =  connectedChain.size() - 1; i > 0; i--) {


            ArrayList<Vertex> Vertices2 = new ArrayList<Vertex>();
            ArrayList<graphEdge> Edges2 = new ArrayList<graphEdge>();
            graphVertices allVer = new graphVertices();
            Graph_Reader.graphEdges allEdges = new graphEdges();
            Vertices2 = allVer.getAllVertices(this.virtualNodes.size(), this.substrateNet);
            Edges2 = allEdges.getAllEdges(this.substrateNet);

            ArrayList<Vertex> currentNode = new ArrayList<Vertex>();
            currentNode.add(connectedChain.get(i));
            
       //     System.out.println("currentNode: " + currentNode.get(0).getNumber() + " connectedChain.get(i - 1): " + connectedChain.get(i - 1).getNumber());
            findShortestPathWithConv shortestPath = new findShortestPathWithConv(Vertices2, Edges2, this.virtualNodes, this.substrateNet);
            ArrayList<Integer> currentPath = shortestPath.findShortest(currentNode, connectedChain.get(i - 1),
                    this.bandWidth);

            Collections.reverse(currentPath);

           // System.out.println("Current path in getUpTuneUpPath:\t"+Arrays.toString(currentPath.toArray()));

            path.addAll(currentPath);
        }

        // remove duplication
      //  System.out.println("Size of path in TuneUP w/ duplication:\t" + Arrays.toString(path.toArray()));
        for (int i = 0; i < path.size() - 1; i++) {

            if (path.get(i) == path.get(i + 1)) {
                path.remove(i + 1);
            }
        }
        
       Collections.reverse(path);

      //  System.out.println("Size of path in TuneUP w/o duplication:\t" + Arrays.toString(path.toArray()));

        return path;
    }

    private ArrayList<Vertex> triangleTuneUp(ArrayList<Vertex> substrateNodes, ArrayList<Vertex> currentChain,
                                             Vertex currentNode, int yValue) {

        int indexOfCurrentNode = findIndexValueOfCurrentNode(currentChain, currentNode);
      //  System.out.println("indexOfCurrentNode: " + indexOfCurrentNode);
        Vertex previousNode = null;
        Vertex nextNode = null;

        if (indexOfCurrentNode > 0) {
            previousNode = currentChain.get(indexOfCurrentNode - 1);
         //   System.out.println("previousNode666: " + previousNode.getNumber());
        }

        if (indexOfCurrentNode < currentChain.size() - 1) {
            nextNode = currentChain.get(indexOfCurrentNode + 1);
          //  System.out.println("nextNode: " + nextNode.getNumber());
        }


        double distance2Previous = Integer.MAX_VALUE;
        double distance2Next = Integer.MAX_VALUE;

        if (previousNode != null) {
            ArrayList<Vertex> currNode = new ArrayList<Vertex>();
            currNode.add(currentNode);
            ArrayList<Integer> retSP = new ArrayList<Integer>();
            // distance2Previous = shortestPath.findShortest(currNode, previousNode,
            // this.bandWidth);
          //  System.out.println("");
            ArrayList<Vertex> Vertices2 = new ArrayList<Vertex>();
            ArrayList<graphEdge> Edges2 = new ArrayList<graphEdge>();
            graphVertices allVer = new graphVertices();
            Graph_Reader.graphEdges allEdges = new graphEdges();
            Vertices2 = allVer.getAllVertices(this.virtualNodes.size(), this.substrateNet);
            Edges2 = allEdges.getAllEdges(this.substrateNet);

//            for (Vertex vertex :
//                    Vertices2) {
//                System.out.println("TTU-Vertex " + vertex + ": Start-End Index: " + vertex.getStartIndex() + " - " + vertex.getEndIndex());
//            }
//            for (graphEdge edge :
//                    Edges2) {
//                System.out.println("TTU-Edge " + edge + " from " + edge.getSource() + " - " + edge.getDestination() + ": Start-End Index: " + edge.getStartIndex() + " - " + edge.getEndIndex());
//            }

            findShortestPathWithConv shortestPath = new findShortestPathWithConv(Vertices2, Edges2, this.virtualNodes, this.substrateNet);
            retSP = shortestPath.findShortest(currNode, previousNode, this.bandWidth);
            if (retSP.isEmpty()) {
                return null;
            }
       //     System.out.println("Shortest path between the current and pre: " + retSP);
            distance2Previous = retSP.size() - 1;

        }

        if (nextNode != null) {
            
       //     System.out.println("came hg");
            ArrayList<Vertex> currNode = new ArrayList<Vertex>();
            //currNode.add(currentNode);
            currNode.add(nextNode);
            ArrayList<Integer> retSP = new ArrayList<Integer>();
            ArrayList<Vertex> Vertices2 = new ArrayList<Vertex>();
            ArrayList<graphEdge> Edges2 = new ArrayList<graphEdge>();
            graphVertices allVer = new graphVertices();
            Graph_Reader.graphEdges allEdges = new graphEdges();
            Vertices2 = allVer.getAllVertices(this.virtualNodes.size(), this.substrateNet);
            Edges2 = allEdges.getAllEdges(this.substrateNet);


            findShortestPathWithConv shortestPath = new findShortestPathWithConv(Vertices2, Edges2, this.virtualNodes, this.substrateNet);
            retSP = shortestPath.findShortest(currNode, currentNode, this.bandWidth);
            if (retSP.isEmpty()) {
                return null;
            }
       //     System.out.println("Shortest path between the current and next: " + retSP);
            distance2Next = retSP.size() - 1;

        }
        else {
            
           distance2Next=0;  //If the last group has just one element
        }

     //   System.out.println("distance2Previous: " + distance2Previous + " for node: " + currentNode );
     //   System.out.println("distance2Next: " + distance2Next);
        double currentDistance = distance2Previous + distance2Next;
      //  System.out.println("currentDistance: " + currentDistance);


        ArrayList<Vertex> substrateCandidatesOfCurrentNode = substrateNeighborCandidates(currentNode, this.usedSub);
//        System.out.println("currentNode: " + currentNode.getNumber());
//        System.out.println("usedsub: " + this.usedSub);
//        System.out.println("treemap: " + this.treemap);

        for (int i = 0; i < substrateCandidatesOfCurrentNode.size(); i++) {
            //System.out.println(
             //       "substrateCandidatesOfCurrentNode: " + substrateCandidatesOfCurrentNode.get(i).getNumber());
        }
        Vertex savedCandidateNode = currentNode;

        for (Vertex candidate : substrateCandidatesOfCurrentNode) {

            distance2Previous = Integer.MAX_VALUE;
            distance2Next = Integer.MAX_VALUE;

			/*
             * Please use your shortest path cost function to find the distance from one
			 * node to another node
			 */

            boolean pathFlag = true;

            if (previousNode != null) {
                ArrayList<Vertex> currNode = new ArrayList<Vertex>();
                currNode.add(candidate);
                ArrayList<Integer> retSP = new ArrayList<Integer>();
                ArrayList<Vertex> Vertices2 = new ArrayList<Vertex>();
                ArrayList<graphEdge> Edges2 = new ArrayList<graphEdge>();
                graphVertices allVer = new graphVertices();
                Graph_Reader.graphEdges allEdges = new graphEdges();
                Vertices2 = allVer.getAllVertices(this.virtualNodes.size(), this.substrateNet);
                Edges2 = allEdges.getAllEdges(this.substrateNet);

                findShortestPathWithConv shortestPath = new findShortestPathWithConv(Vertices2, Edges2, this.virtualNodes, this.substrateNet);
                retSP = shortestPath.findShortest(currNode, previousNode, this.bandWidth);
             //   System.out.println("TTU-ShortestPath-Previous From " + candidate + " - " + previousNode + ": " + Arrays.toString(retSP.toArray()));

                if (retSP == null || retSP.isEmpty()) {
                    pathFlag = false;
                }
                distance2Previous = retSP.size() - 1;
            }

            if (nextNode != null) {
                ArrayList<Vertex> currNode = new ArrayList<Vertex>();
                currNode.add(nextNode);
                ArrayList<Integer> retSP = new ArrayList<Integer>();
                ArrayList<Vertex> Vertices2 = new ArrayList<Vertex>();
                ArrayList<graphEdge> Edges2 = new ArrayList<graphEdge>();
                graphVertices allVer = new graphVertices();
                Graph_Reader.graphEdges allEdges = new graphEdges();
                Vertices2 = allVer.getAllVertices(this.virtualNodes.size(), this.substrateNet);
                Edges2 = allEdges.getAllEdges(this.substrateNet);

                findShortestPathWithConv shortestPath = new findShortestPathWithConv(Vertices2, Edges2, this.virtualNodes, this.substrateNet);
                retSP = shortestPath.findShortest(currNode, candidate, this.bandWidth);
              //  System.out.println("TTU-ShortestPath-Next From " + candidate + " - " + nextNode + ": " + Arrays.toString(retSP.toArray()));
                if (retSP == null || retSP.isEmpty() ) {
                    pathFlag = false;
                }
                distance2Next = retSP.size() - 1;
            }

            double newCalculatedDistance = distance2Previous + distance2Next;

            if (newCalculatedDistance < currentDistance && pathFlag) {
                currentDistance = newCalculatedDistance;
                savedCandidateNode = candidate;
         //       System.out.println("found one for the node: " + currentNode);
           //      System.out.println("Candidate for migration: " + savedCandidateNode.getNumber() + " with the distance of: "
            //        + currentDistance);
            }
           

        }

     //   System.out.println("Current chain before TTU:\t" + Arrays.toString(currentChain.toArray()));

        currentChain = updateCurrentChainWithNewClosestNode(currentChain, savedCandidateNode, previousNode, nextNode,
                indexOfCurrentNode);
        this.indexValue = 1;
        
          //      System.out.println("Current chain after  TTU:\t" + Arrays.toString(currentChain.toArray()));


        return currentChain;
    }

    private ArrayList<Vertex> updateCurrentChainWithNewClosestNode(ArrayList<Vertex> currentChain, Vertex candidate,
                                                                   Vertex previousNode, Vertex nextNode, int indexOfCurrentNode) {

        ArrayList<Vertex> previousChain = new ArrayList<Vertex>();
        ArrayList<Vertex> nextChain = new ArrayList<Vertex>();

        for (int index = 0; index < indexOfCurrentNode; index++) {
            previousChain.add(currentChain.get(index));
          //  System.out.println("previousChain element: " + previousChain.get(index).getNumber());
        }

        for (int index = indexOfCurrentNode + 1; index < currentChain.size(); index++) {
            nextChain.add(currentChain.get(index));

        }
        for (int i = 0; i < nextChain.size(); i++) {

        //    System.out.println("nextChain element: " + nextChain.get(i).getNumber());

        }

        currentChain.clear();

        currentChain.addAll(previousChain);
        currentChain.add(candidate);
        currentChain.addAll(nextChain);

     //   System.out.println("Current Chain after TTU in updated:\t" + Arrays.toString(currentChain.toArray()));

        return currentChain;
    }

    private int findIndexValueOfCurrentNode(ArrayList<Vertex> currentChain, Vertex currentNode) {

        int indexValue = 0;

        for (int index = 0; index < currentChain.size(); index++) {

            if (currentChain.get(index).getNumber() == currentNode.getNumber()) {
                indexValue = index;
            }
        }
      //  System.out.println("currentNode: " + currentNode + " index:  " + indexValue);
        return indexValue;
    }

    // private ArrayList<Vertex> substrateNeighborCandidates(ArrayList<Vertex>
    // currentNode, ArrayList<Vertex> substrateNodes){

    private ArrayList<Vertex> substrateNeighborCandidates(Vertex currentNode, ArrayList<Integer> usedSubSFC) {

       // System.out.println("currentNode: " + currentNode.getNumber());
        ArrayList<Vertex> substrateNeighbors = new ArrayList<Vertex>();
        Set<Integer> keys = this.treemap.keySet();// defined to provide an access to the functionodes and their
        // candidates
        for (Integer r : keys) {
            if (r == currentNode.getOfferedFunc().get(0)) {
              //  System.out.println("in treemap: " + currentNode.getOfferedFunc().get(0));
                for (Integer s : this.treemap.get(r)) {
                    if (!usedSubSFC.contains(s)) {
                        substrateNeighbors.add(this.substrateNodes.get(s));
                    }
                }

            }
        }

        return substrateNeighbors;
    }

    private ArrayList<Vertex> getConvertedChainFromGroups(ArrayList<ArrayList<Vertex>> currentChain) {

        ArrayList<Vertex> chainWithOutGroups = new ArrayList<Vertex>();

        for (ArrayList<Vertex> group : currentChain) {

            for (Vertex currentNode : group) {

                chainWithOutGroups.add(currentNode);
            } // end-for group

        } // end-for currentChain

        return chainWithOutGroups;
    }

    public ArrayList<ArrayList<Vertex>> getTunedUpGivenChain() {
        return givenChain;
    }

    public Vertex getNodeVer(int number) {
        Vertex helpVer = new Vertex();
        for (int i = 0; i < this.substrateNodes.size(); i++) {

            if (this.substrateNodes.get(i).getNumber() == number) {

                helpVer = this.substrateNodes.get(i);
            }

        }

        return helpVer;
    }
}
